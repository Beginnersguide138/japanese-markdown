<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="JAMdown Pad - Japanese Markdown Editor with full-width character support">
    <title>JAMdown Pad - Japanese Markdown Editor</title>

    <!-- Marked.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/marked@latest/marked.min.js"></script>

    <style>
        /* CSS Variables for theming */
        :root {
            --bg-primary: #f8f9fa;
            --bg-secondary: #fff;
            --bg-tertiary: #f8f9fa;
            --text-primary: #333;
            --text-secondary: #6c757d;
            --text-accent: #2c3e50;
            --border-color: #e9ecef;
            --border-light: #dee2e6;
            --accent-color: #007bff;
            --success-bg: #d4edda;
            --success-border: #c3e6cb;
            --success-text: #155724;
            --code-bg: #f8f9fa;
            --shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3a3a3a;
            --text-primary: #e9ecef;
            --text-secondary: #adb5bd;
            --text-accent: #f8f9fa;
            --border-color: #495057;
            --border-light: #6c757d;
            --accent-color: #4dabf7;
            --success-bg: #155724;
            --success-border: #28a745;
            --success-text: #d4edda;
            --code-bg: #3a3a3a;
            --shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background-color: var(--bg-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Header */
        header {
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .header-text {
            text-align: center;
            flex: 1;
        }

        header h1 {
            color: var(--text-accent);
            margin-bottom: 0.5rem;
            font-size: 2rem;
        }

        header p {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .theme-toggle {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .theme-toggle:hover {
            color: var(--text-accent);
            background-color: var(--bg-tertiary);
            border-color: var(--border-light);
        }

        .github-link {
            color: var(--text-secondary);
            transition: color 0.2s ease;
            display: flex;
            align-items: center;
            padding: 0.5rem;
            border-radius: 4px;
        }

        .github-link:hover {
            color: var(--text-accent);
            background-color: var(--bg-tertiary);
        }

        /* Main container */
        .app-container {
            display: flex;
            height: calc(100vh - 140px);
            gap: 1px;
            background-color: var(--border-color);
        }

        /* Editor section */
        .editor-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-secondary);
        }

        .editor-header {
            padding: 1rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-header h2 {
            font-size: 1.2rem;
            color: var(--text-secondary);
        }

        .editor-controls {
            display: flex;
            gap: 0.5rem;
        }

        #editor {
            flex: 1;
            border: none;
            padding: 1rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            outline: none;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        #editor::placeholder {
            color: var(--text-secondary);
            opacity: 0.8;
        }

        /* Preview section */
        .preview-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-secondary);
        }

        .preview-header {
            padding: 1rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-header h2 {
            font-size: 1.2rem;
            color: var(--text-secondary);
        }

        .preview-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .download-group {
            display: flex;
            gap: 0.25rem;
        }

        .download-group button {
            font-size: 0.8rem;
            padding: 0.4rem 0.8rem;
        }

        .preview-content {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            background: var(--bg-secondary);
        }

        /* Button styles */
        button {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-light);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s ease;
        }

        button:hover {
            background: var(--bg-tertiary);
            border-color: var(--text-secondary);
        }

        button:active {
            background: var(--border-color);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Preview content styling */
        .preview-content h1,
        .preview-content h2,
        .preview-content h3,
        .preview-content h4,
        .preview-content h5,
        .preview-content h6 {
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            color: var(--text-accent);
        }

        .preview-content h1 {
            font-size: 2rem;
        }

        .preview-content h2 {
            font-size: 1.5rem;
        }

        .preview-content h3 {
            font-size: 1.25rem;
        }

        .preview-content h4 {
            font-size: 1.1rem;
        }

        .preview-content h5 {
            font-size: 1rem;
        }

        .preview-content h6 {
            font-size: 0.9rem;
        }

        .preview-content p {
            margin-bottom: 1rem;
        }

        .preview-content ul,
        .preview-content ol {
            margin-bottom: 1rem;
            padding-left: 2rem;
        }

        .preview-content li {
            margin-bottom: 0.25rem;
        }

        .preview-content blockquote {
            border-left: 4px solid var(--border-light);
            padding-left: 1rem;
            margin: 1rem 0;
            color: var(--text-secondary);
            font-style: italic;
        }

        .preview-content code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.875rem;
            color: var(--text-primary);
        }

        .preview-content pre {
            background: var(--code-bg);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        .preview-content pre code {
            background: none;
            padding: 0;
        }

        .preview-content hr {
            border: none;
            border-top: 1px solid var(--border-light);
            margin: 2rem 0;
        }

        .preview-content a {
            color: var(--accent-color);
            text-decoration: none;
        }

        .preview-content a:hover {
            text-decoration: underline;
        }

        /* Table styling */
        .preview-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
            background: var(--bg-secondary);
            border-radius: 6px;
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        .preview-content th,
        .preview-content td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .preview-content th {
            background: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border-light);
        }

        .preview-content tr:hover {
            background: var(--bg-tertiary);
        }

        .preview-content tr:last-child td {
            border-bottom: none;
        }

        /* Table alignment classes */
        .preview-content th[align="center"],
        .preview-content td[align="center"] {
            text-align: center;
        }

        .preview-content th[align="right"],
        .preview-content td[align="right"] {
            text-align: right;
        }

        .preview-content th[align="left"],
        .preview-content td[align="left"] {
            text-align: left;
        }

        /* Task list styling */
        .preview-content input[type="checkbox"] {
            margin-right: 0.5rem;
            transform: scale(1.1);
        }

        .preview-content li:has(input[type="checkbox"]) {
            list-style: none;
            margin-left: -1.5rem;
        }

        /* Strikethrough styling */
        .preview-content del {
            color: #6c757d;
            text-decoration-thickness: 2px;
        }

        /* Responsive table */
        @media (max-width: 768px) {
            .preview-content table {
                font-size: 0.875rem;
            }

            .preview-content th,
            .preview-content td {
                padding: 0.5rem 0.75rem;
            }
        }

        /* Footer */
        footer {
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .footer-links {
            margin-top: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .footer-links a {
            color: var(--accent-color);
            text-decoration: none;
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            transition: background-color 0.2s ease;
        }

        .footer-links a:hover {
            background-color: var(--bg-tertiary);
            text-decoration: none;
        }

        .footer-links span {
            color: var(--border-light);
            font-size: 0.8rem;
        }

        /* Editor Toolbar */
        .editor-toolbar {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            gap: 0.5rem;
            flex-wrap: wrap;
            overflow-x: auto;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .toolbar-separator {
            width: 1px;
            height: 20px;
            background: var(--border-color);
            margin: 0 0.25rem;
        }

        .toolbar-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            padding: 0;
            border: 1px solid transparent;
            background: transparent;
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0;
        }

        .toolbar-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--border-color);
        }

        .toolbar-btn:active {
            background: var(--border-color);
            transform: translateY(1px);
        }

        .toolbar-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Auto Save Indicator */
        .save-indicator {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            background: transparent;
            transition: all 0.3s ease;
        }

        .save-indicator svg {
            width: 12px;
            height: 12px;
            opacity: 0.7;
        }

        .save-indicator.saving {
            color: var(--accent-color);
            background: var(--bg-secondary);
        }

        .save-indicator.saving svg {
            animation: pulse 1.5s ease-in-out infinite;
        }

        .save-indicator.saved {
            color: var(--success-text);
            background: var(--success-bg);
        }

        .save-indicator.error {
            color: #dc3545;
            background: #f8d7da;
        }

        .save-indicator.loaded {
            color: var(--accent-color);
            background: var(--bg-secondary);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.7;
            }

            50% {
                opacity: 1;
            }
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
                height: auto;
                min-height: calc(100vh - 140px);
            }

            .editor-section,
            .preview-section {
                min-height: 300px;
            }

            header {
                padding: 1rem;
            }

            .header-content {
                flex-direction: column;
                gap: 1rem;
            }

            header h1 {
                font-size: 1.5rem;
            }

            .editor-header,
            .preview-header {
                padding: 0.75rem;
                flex-direction: column;
                gap: 0.5rem;
                align-items: stretch;
            }

            .editor-controls,
            .preview-controls {
                justify-content: center;
            }

            #editor {
                padding: 0.75rem;
                font-size: 16px;
                /* Prevent zoom on iOS */
            }

            .preview-content {
                padding: 0.75rem;
            }

            .editor-toolbar {
                padding: 0.5rem;
                gap: 0.25rem;
            }

            .toolbar-group {
                gap: 0.125rem;
            }

            .toolbar-btn {
                width: 28px;
                height: 28px;
            }

            .toolbar-separator {
                height: 16px;
            }

            .save-indicator {
                font-size: 0.7rem;
                padding: 0.2rem 0.4rem;
            }

            .save-indicator svg {
                width: 10px;
                height: 10px;
            }
        }

        @media (max-width: 480px) {
            header {
                padding: 0.75rem;
            }

            .header-content {
                gap: 0.75rem;
            }

            header h1 {
                font-size: 1.25rem;
            }

            .editor-controls,
            .preview-controls {
                flex-direction: column;
            }

            .download-group {
                flex-direction: column;
                width: 100%;
            }

            .download-group button {
                font-size: 0.9rem;
                padding: 0.6rem;
            }

            button {
                padding: 0.75rem;
                font-size: 0.9rem;
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="header-content">
            <div class="header-text">
                <h1>JAMdown Pad</h1>
                <p>Japanese Markdown Editor - 日本語記法対応マークダウンエディタ</p>
            </div>
            <div class="header-controls">
                <button id="theme-toggle" class="theme-toggle" title="ダークモード切り替え">
                    <svg class="sun-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5" />
                        <line x1="12" y1="1" x2="12" y2="3" />
                        <line x1="12" y1="21" x2="12" y2="23" />
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" />
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" />
                        <line x1="1" y1="12" x2="3" y2="12" />
                        <line x1="21" y1="12" x2="23" y2="12" />
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" />
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" />
                    </svg>
                    <svg class="moon-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" />
                    </svg>
                </button>
                <a href="https://github.com/Beginnersguide138/japanese-markdown" target="_blank" rel="noopener"
                    class="github-link" title="GitHubリポジトリ"></a>
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                    <path
                        d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
                </svg>
                </a>
            </div>
        </div>
    </header>

    <main class="app-container">
        <!-- Two-pane layout -->
        <div class="editor-section">
            <div class="editor-header">
                <h2>エディタ</h2>
                <div class="editor-controls">
                    <input type="file" id="file-input" accept=".md,.jamd,.jmd,.txt" style="display: none;">
                    <button id="upload-btn" type="button">ファイルを開く</button>
                    <button id="clear-btn" type="button" title="内容をクリア">🗑️</button>
                </div>
            </div>
            <textarea id="editor" placeholder="日本語マークダウンを入力してください...
例：
＃ 見出し
＊＊太字＊＊
＊斜体＊
＞ 引用
・ リスト項目
１． 番号付きリスト
｜列１｜列２｜
｜：ー｜：ー：｜
｜データ１｜データ２｜
｀コード｀
〜〜取り消し〜〜
□ タスク
☑ 完了"></textarea>
            <div class="editor-toolbar">
                <div class="toolbar-group">
                    <button class="toolbar-btn" data-action="heading" title="見出し (＃)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M6 12h12M6 20V4M18 20V4" />
                        </svg>
                    </button>
                    <button class="toolbar-btn" data-action="bold" title="太字 (＊＊)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6zM6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z" />
                        </svg>
                    </button>
                    <button class="toolbar-btn" data-action="italic" title="斜体 (＊)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M19 4h-9M14 20H5M15 4L9 20" />
                        </svg>
                    </button>
                    <button class="toolbar-btn" data-action="strikethrough" title="取り消し線 (〜〜)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M16 4H9a3 3 0 0 0-2.83 4M14 12a4 4 0 0 1 0 8H6M3 12h18" />
                        </svg>
                    </button>
                </div>
                <div class="toolbar-separator"></div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" data-action="quote" title="引用 (＞)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path
                                d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1zM15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z" />
                        </svg>
                    </button>
                    <button class="toolbar-btn" data-action="code" title="インラインコード (｀)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <polyline points="16,18 22,12 16,6" />
                            <polyline points="8,6 2,12 8,18" />
                        </svg>
                    </button>
                    <button class="toolbar-btn" data-action="codeblock" title="コードブロック (｀｀｀)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <rect x="3" y="5" width="18" height="14" rx="2" ry="2" />
                            <line x1="7" y1="9" x2="13" y2="9" />
                            <line x1="7" y1="12" x2="17" y2="12" />
                            <line x1="7" y1="15" x2="11" y2="15" />
                        </svg>
                    </button>
                </div>
                <div class="toolbar-separator"></div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" data-action="link" title="リンク 「」（）">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72" />
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72" />
                        </svg>
                    </button>
                    <button class="toolbar-btn" data-action="image" title="画像 ！「」（）">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                            <circle cx="8.5" cy="8.5" r="1.5" />
                            <polyline points="21,15 16,10 5,21" />
                        </svg>
                    </button>
                </div>
                <div class="toolbar-separator"></div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" data-action="ul" title="箇条書き (・)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <line x1="8" y1="6" x2="21" y2="6" />
                            <line x1="8" y1="12" x2="21" y2="12" />
                            <line x1="8" y1="18" x2="21" y2="18" />
                            <line x1="3" y1="6" x2="3.01" y2="6" />
                            <line x1="3" y1="12" x2="3.01" y2="12" />
                            <line x1="3" y1="18" x2="3.01" y2="18" />
                        </svg>
                    </button>
                    <button class="toolbar-btn" data-action="ol" title="番号付きリスト (１．)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <line x1="10" y1="6" x2="21" y2="6" />
                            <line x1="10" y1="12" x2="21" y2="12" />
                            <line x1="10" y1="18" x2="21" y2="18" />
                            <path d="M4 6h1v4" />
                            <path d="M4 10h2" />
                            <path d="M6 18H4c0-1 2-2 2-3s-1-1.5-2-1" />
                        </svg>
                    </button>
                    <button class="toolbar-btn" data-action="task" title="タスクリスト (□)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <rect x="3" y="5" width="6" height="6" rx="1" />
                            <path d="M21 12H12" />
                            <path d="M21 6H12" />
                            <path d="M21 18H12" />
                            <path d="M6 8L7 9L9 7" />
                        </svg>
                    </button>
                </div>
                <div class="toolbar-separator"></div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" data-action="table" title="テーブル (｜)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path
                                d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18" />
                        </svg>
                    </button>
                    <button class="toolbar-btn" data-action="hr" title="水平線 (ーーー)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <line x1="3" y1="12" x2="21" y2="12" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <div class="preview-section">
            <div class="preview-header">
                <h2>プレビュー</h2>
                <div class="preview-controls">
                    <div class="download-group">
                        <button id="download-md-btn" type="button">.md保存</button>
                        <button id="download-jamd-btn" type="button">.jamd保存</button>
                        <button id="download-jmd-btn" type="button">.jmd保存</button>
                    </div>
                    <button id="copy-html-btn" type="button">HTMLコピー</button>
                </div>
            </div>
            <div id="preview" class="preview-content"></div>
        </div>
    </main>

    <footer>
        <p>JAMdown Pad - シームレスな日本語マークダウン編集</p>
        <div class="footer-links">
            <a href="https://github.com/Beginnersguide138/japanese-markdown/blob/main/README.md" target="_blank"
                rel="noopener">📖 README</a>
            <span>|</span>
            <a href="https://github.com/Beginnersguide138/japanese-markdown/blob/main/LICENSE" target="_blank"
                rel="noopener">📄 LICENSE</a>
            <span>|</span>
            <a href="https://github.com/Beginnersguide138/japanese-markdown" target="_blank" rel="noopener">🐙
                GitHub</a>
        </div>
    </footer>

    <script>
        // Normalization Engine - Core conversion logic for Japanese to standard Markdown
        class NormalizationEngine {
            // Helper function to convert full-width numbers to half-width
            static convertFullWidthNumber(fullWidthNum) {
                const fullWidthNumbers = '０１２３４５６７８９';
                const halfWidthNumbers = '0123456789';
                let result = '';
                for (let char of fullWidthNum) {
                    const index = fullWidthNumbers.indexOf(char);
                    result += index !== -1 ? halfWidthNumbers[index] : char;
                }
                return result;
            }

            // Get all conversion rules as a Map
            static getConversionRules() {
                return new Map([
                    // Headings: ＃ to #
                    [/^(＃{1,6})\s*/gm, (match, hashes) => '#'.repeat(hashes.length) + ' '],

                    // Bold: ＊＊text＊＊ to **text**
                    [/＊＊([^＊]+?)＊＊/g, '**$1**'],

                    // Italic: ＊text＊ to *text* (but not if it's part of bold)
                    [/(?<!\*)＊([^＊]+?)＊(?!\*)/g, '*$1*'],

                    // Blockquotes: ＞ to >
                    [/^＞\s*/gm, '> '],

                    // Links: 「link name」（URL） to [link name](URL)
                    [/「([^」]+)」（([^）]+)）/g, '[$1]($2)'],

                    // Code blocks: ｀｀｀ to ```
                    [/｀｀｀/g, '```'],

                    // Horizontal rules: ＊＊＊ to ***
                    [/^＊＊＊\s*$/gm, '***'],

                    // Horizontal rules: ーーー to ---
                    [/^ーーー\s*$/gm, '---'],

                    // Bullet lists: ・ to *
                    [/^・\s*/gm, '* '],

                    // Numbered lists: １． to 1. (with full-width number conversion)
                    [/^([０-９]+)．\s*/gm, (match, num) => {
                        return NormalizationEngine.convertFullWidthNumber(num) + '. ';
                    }],

                    // Table support: ｜ to |
                    [/｜/g, '|'],

                    // Table alignment: ：ー to :- and ：ー： to :-:
                    [/：ー：/g, ':-:'],
                    [/：ー/g, ':-'],
                    [/ー：/g, '-:'],

                    // Inline code: ｀code｀ to `code`
                    [/｀([^｀]+?)｀/g, '`$1`'],

                    // Strikethrough: 〜〜text〜〜 to ~~text~~
                    [/〜〜([^〜]+?)〜〜/g, '~~$1~~'],

                    // Task lists: □ and ☑ to - [ ] and - [x]
                    [/^□\s*/gm, '- [ ] '],
                    [/^☑\s*/gm, '- [x] '],

                    // Images: ！「alt text」（URL） to ![alt text](URL)
                    [/！「([^」]+)」（([^）]+)）/g, '![$1]($2)'],

                    // Footnotes: ［＾number］ to [^number]
                    [/［＾([０-９]+)］/g, (match, num) => {
                        return '[^' + NormalizationEngine.convertFullWidthNumber(num) + ']';
                    }],

                    // Additional common full-width symbols
                    [/：/g, ':'],
                    [/；/g, ';'],
                    [/，/g, ','],
                    [/．/g, '.'],
                    [/？/g, '?'],
                    [/！/g, '!'],
                    [/（/g, '('],
                    [/）/g, ')'],
                    [/［/g, '['],
                    [/］/g, ']'],
                    [/｛/g, '{'],
                    [/｝/g, '}'],
                ]);
            }

            // Main normalization method
            static normalize(text) {
                if (!text || typeof text !== 'string') {
                    return '';
                }

                let normalizedText = text;
                const rules = this.getConversionRules();

                // Apply each conversion rule
                for (let [pattern, replacement] of rules) {
                    normalizedText = normalizedText.replace(pattern, replacement);
                }

                return normalizedText;
            }

            // Test method to verify conversions
            static test() {
                const testCases = [
                    { input: '＃ 見出し１', expected: '# 見出し１' },
                    { input: '＃＃ 見出し２', expected: '## 見出し２' },
                    { input: '＊＊太字＊＊', expected: '**太字**' },
                    { input: '＊斜体＊', expected: '*斜体*' },
                    { input: '＞ 引用文', expected: '> 引用文' },
                    { input: '「リンク」（https://example.com）', expected: '[リンク](https://example.com)' },
                    { input: '｀｀｀javascript', expected: '```javascript' },
                    { input: '＊＊＊', expected: '***' },
                    { input: 'ーーー', expected: '---' },
                    { input: '・ リスト項目', expected: '* リスト項目' },
                    { input: '１． 番号付きリスト', expected: '1. 番号付きリスト' },
                    { input: '｜列１｜列２｜', expected: '|列１|列２|' },
                    { input: '｜：ー｜：ー：｜', expected: '|:-|:-:|' },
                    { input: '｜データ１｜データ２｜', expected: '|データ１|データ２|' },
                    { input: '｀コード｀', expected: '`コード`' },
                    { input: '〜〜取り消し〜〜', expected: '~~取り消し~~' },
                    { input: '□ 未完了タスク', expected: '- [ ] 未完了タスク' },
                    { input: '☑ 完了タスク', expected: '- [x] 完了タスク' },
                    { input: '！「画像説明」（image.jpg）', expected: '![画像説明](image.jpg)' },
                    { input: '［＾１］', expected: '[^1]' },
                ];

                console.log('Testing NormalizationEngine...');
                let passed = 0;
                let failed = 0;

                testCases.forEach((testCase, index) => {
                    const result = this.normalize(testCase.input);
                    if (result === testCase.expected) {
                        console.log(`✓ Test ${index + 1} passed: "${testCase.input}" → "${result}"`);
                        passed++;
                    } else {
                        console.error(`✗ Test ${index + 1} failed: "${testCase.input}" → "${result}" (expected: "${testCase.expected}")`);
                        failed++;
                    }
                });

                console.log(`Test results: ${passed} passed, ${failed} failed`);
                return failed === 0;
            }
        }

        // Editor Controller - Manages textarea input and real-time updates
        class EditorController {
            constructor(textareaElement) {
                this.textarea = textareaElement;
                this.callbacks = [];
                this.debounceTimer = null;
                this.debounceDelay = 150; // 150ms debounce for optimal performance

                this.setupEventListeners();
            }

            setupEventListeners() {
                // Input event with debouncing
                this.textarea.addEventListener('input', (event) => {
                    this.handleInput();
                });

                // Handle paste events
                this.textarea.addEventListener('paste', (event) => {
                    // Small delay to allow paste content to be processed
                    setTimeout(() => this.handleInput(), 10);
                });

                // Handle keyboard shortcuts
                this.textarea.addEventListener('keydown', (event) => {
                    this.handleKeydown(event);
                });
            }

            handleInput() {
                // Clear existing timer
                if (this.debounceTimer) {
                    clearTimeout(this.debounceTimer);
                }

                // Set new timer
                this.debounceTimer = setTimeout(() => {
                    const text = this.getText();
                    this.notifyCallbacks(text);
                }, this.debounceDelay);
            }

            handleKeydown(event) {
                // Handle Tab key for indentation
                if (event.key === 'Tab') {
                    event.preventDefault();
                    const start = this.textarea.selectionStart;
                    const end = this.textarea.selectionEnd;
                    const text = this.textarea.value;

                    // Insert tab or spaces
                    const tabChar = '    '; // 4 spaces
                    this.textarea.value = text.substring(0, start) + tabChar + text.substring(end);
                    this.textarea.selectionStart = this.textarea.selectionEnd = start + tabChar.length;

                    this.handleInput();
                }
            }

            onInput(callback) {
                if (typeof callback === 'function') {
                    this.callbacks.push(callback);
                }
            }

            notifyCallbacks(text) {
                this.callbacks.forEach(callback => {
                    try {
                        callback(text);
                    } catch (error) {
                        console.error('Error in editor callback:', error);
                    }
                });
            }

            getText() {
                return this.textarea.value || '';
            }

            setText(text) {
                if (typeof text === 'string') {
                    this.textarea.value = text;
                    this.handleInput();
                }
            }

            // Get cursor position for advanced features
            getCursorPosition() {
                return {
                    start: this.textarea.selectionStart,
                    end: this.textarea.selectionEnd
                };
            }

            // Set cursor position
            setCursorPosition(start, end = start) {
                this.textarea.selectionStart = start;
                this.textarea.selectionEnd = end;
                this.textarea.focus();
            }

            // Insert text at cursor position
            insertText(text) {
                const start = this.textarea.selectionStart;
                const end = this.textarea.selectionEnd;
                const currentText = this.textarea.value;

                this.textarea.value = currentText.substring(0, start) + text + currentText.substring(end);
                this.setCursorPosition(start + text.length);
                this.handleInput();
            }

            // Focus the editor
            focus() {
                this.textarea.focus();
            }

            // Clear the editor
            clear() {
                this.setText('');
            }

            // Get text statistics
            getStats() {
                const text = this.getText();
                return {
                    characters: text.length,
                    charactersNoSpaces: text.replace(/\s/g, '').length,
                    words: text.trim() ? text.trim().split(/\s+/).length : 0,
                    lines: text.split('\n').length,
                    paragraphs: text.split(/\n\s*\n/).filter(p => p.trim()).length
                };
            }
        }

        // Initialize application
        console.log('JAMdown Pad initialized');

        // Basic marked.js availability check
        if (typeof marked === 'undefined') {
            console.error('marked.js failed to load');
            document.getElementById('preview').innerHTML = '<p style="color: red;">Error: Markdown parser failed to load. Please refresh the page.</p>';
        } else {
            console.log('marked.js loaded successfully');

            // Test the normalization engine
            NormalizationEngine.test();

            // Preview Controller - Manages HTML rendering using marked.js
            class PreviewController {
                constructor(previewElement) {
                    this.previewElement = previewElement;
                    this.currentHTML = '';
                    this.isProcessing = false;

                    this.setupMarkedOptions();
                }

                setupMarkedOptions() {
                    // Configure marked.js options for better rendering
                    if (typeof marked !== 'undefined' && marked.setOptions) {
                        marked.setOptions({
                            breaks: true, // Convert \n to <br>
                            gfm: true, // GitHub Flavored Markdown
                            headerIds: false, // Don't add IDs to headers
                            mangle: false, // Don't mangle email addresses
                            sanitize: false, // Allow HTML (marked.js has built-in XSS protection)
                        });
                    }
                }

                render(markdownText) {
                    if (this.isProcessing) {
                        return;
                    }

                    try {
                        this.isProcessing = true;

                        // Handle empty input
                        if (!markdownText || typeof markdownText !== 'string') {
                            this.currentHTML = '';
                            this.updatePreview('');
                            return;
                        }

                        // Convert markdown to HTML using marked.js
                        let html = '';
                        if (typeof marked !== 'undefined') {
                            if (typeof marked.parse === 'function') {
                                // marked v4+ syntax
                                html = marked.parse(markdownText);
                            } else if (typeof marked === 'function') {
                                // marked v3 and earlier syntax
                                html = marked(markdownText);
                            } else {
                                throw new Error('marked.js API not recognized');
                            }
                        } else {
                            throw new Error('marked.js not available');
                        }

                        this.currentHTML = html;
                        this.updatePreview(html);

                    } catch (error) {
                        console.error('Error rendering markdown:', error);
                        this.handleRenderError(error, markdownText);
                    } finally {
                        this.isProcessing = false;
                    }
                }

                updatePreview(html) {
                    if (this.previewElement) {
                        this.previewElement.innerHTML = html;

                        // Scroll to top if content changed significantly
                        if (this.previewElement.scrollTop > 0 && html.length < 100) {
                            this.previewElement.scrollTop = 0;
                        }
                    }
                }

                handleRenderError(error, markdownText) {
                    const errorMessage = `
                        <div style="color: #dc3545; padding: 1rem; border: 1px solid #dc3545; border-radius: 4px; background: #f8d7da;">
                            <h4>Rendering Error</h4>
                            <p><strong>Error:</strong> ${error.message}</p>
                            <p><strong>Input length:</strong> ${markdownText ? markdownText.length : 0} characters</p>
                            <p>Please check your markdown syntax or try refreshing the page.</p>
                        </div>
                    `;
                    this.updatePreview(errorMessage);
                }

                getHTML() {
                    return this.currentHTML;
                }

                // Get plain text content (for statistics)
                getPlainText() {
                    if (this.previewElement) {
                        return this.previewElement.textContent || this.previewElement.innerText || '';
                    }
                    return '';
                }

                // Clear the preview
                clear() {
                    this.currentHTML = '';
                    this.updatePreview('');
                }

                // Check if marked.js is available and working
                static isMarkedAvailable() {
                    try {
                        if (typeof marked === 'undefined') {
                            return false;
                        }

                        // Test basic functionality
                        const testMarkdown = '# Test';
                        let result = '';

                        if (typeof marked.parse === 'function') {
                            result = marked.parse(testMarkdown);
                        } else if (typeof marked === 'function') {
                            result = marked(testMarkdown);
                        } else {
                            return false;
                        }

                        return result.includes('<h1>') && result.includes('Test');
                    } catch (error) {
                        console.error('marked.js availability test failed:', error);
                        return false;
                    }
                }
            }

            // Initialize editor controller
            const editorElement = document.getElementById('editor');
            const previewElement = document.getElementById('preview');

            if (editorElement && previewElement) {
                const editorController = new EditorController(editorElement);
                const previewController = new PreviewController(previewElement);

                console.log('EditorController initialized');
                console.log('PreviewController initialized');

                // Editor Toolbar Manager - Define before use
                class EditorToolbar {
                    constructor(editorController) {
                        this.editor = editorController;
                        this.init();
                    }

                    init() {
                        const toolbar = document.querySelector('.editor-toolbar');
                        if (toolbar) {
                            toolbar.addEventListener('click', (e) => {
                                const btn = e.target.closest('.toolbar-btn');
                                if (btn) {
                                    const action = btn.dataset.action;
                                    this.handleAction(action);
                                }
                            });
                        }
                    }

                    handleAction(action) {
                        const textarea = this.editor.textarea;
                        const start = textarea.selectionStart;
                        const end = textarea.selectionEnd;
                        const selectedText = textarea.value.substring(start, end);
                        const beforeText = textarea.value.substring(0, start);
                        const afterText = textarea.value.substring(end);

                        let insertText = '';
                        let cursorOffset = 0;

                        switch (action) {
                            case 'heading':
                                insertText = selectedText ? `＃ ${selectedText}` : '＃ 見出し';
                                cursorOffset = selectedText ? 0 : -2;
                                break;

                            case 'bold':
                                insertText = selectedText ? `＊＊${selectedText}＊＊` : '＊＊太字＊＊';
                                cursorOffset = selectedText ? 0 : -3;
                                break;

                            case 'italic':
                                insertText = selectedText ? `＊${selectedText}＊` : '＊斜体＊';
                                cursorOffset = selectedText ? 0 : -2;
                                break;

                            case 'strikethrough':
                                insertText = selectedText ? `〜〜${selectedText}〜〜` : '〜〜取り消し〜〜';
                                cursorOffset = selectedText ? 0 : -3;
                                break;

                            case 'quote':
                                const lines = selectedText ? selectedText.split('\n') : ['引用文'];
                                insertText = lines.map(line => `＞ ${line}`).join('\n');
                                cursorOffset = selectedText ? 0 : -2;
                                break;

                            case 'code':
                                insertText = selectedText ? `｀${selectedText}｀` : '｀コード｀';
                                cursorOffset = selectedText ? 0 : -2;
                                break;

                            case 'codeblock':
                                insertText = selectedText ? `｀｀｀\n${selectedText}\n｀｀｀` : '｀｀｀\nコード\n｀｀｀';
                                cursorOffset = selectedText ? 0 : -5;
                                break;

                            case 'link':
                                insertText = selectedText ? `「${selectedText}」（URL）` : '「リンクテキスト」（URL）';
                                cursorOffset = selectedText ? -4 : -12;
                                break;

                            case 'image':
                                insertText = selectedText ? `！「${selectedText}」（画像URL）` : '！「画像説明」（画像URL）';
                                cursorOffset = selectedText ? -6 : -14;
                                break;

                            case 'ul':
                                const ulLines = selectedText ? selectedText.split('\n') : ['リスト項目'];
                                insertText = ulLines.map(line => `・ ${line}`).join('\n');
                                cursorOffset = selectedText ? 0 : -4;
                                break;

                            case 'ol':
                                const olLines = selectedText ? selectedText.split('\n') : ['リスト項目'];
                                insertText = olLines.map((line, index) => `${this.toFullWidthNumber(index + 1)}． ${line}`).join('\n');
                                cursorOffset = selectedText ? 0 : -4;
                                break;

                            case 'task':
                                const taskLines = selectedText ? selectedText.split('\n') : ['タスク項目'];
                                insertText = taskLines.map(line => `□ ${line}`).join('\n');
                                cursorOffset = selectedText ? 0 : -4;
                                break;

                            case 'table':
                                insertText = '｜列１｜列２｜列３｜\n｜：ー｜：ー：｜ー：｜\n｜データ１｜データ２｜データ３｜';
                                cursorOffset = -25;
                                break;

                            case 'hr':
                                insertText = 'ーーー';
                                cursorOffset = 0;
                                break;

                            default:
                                return;
                        }

                        // Insert text and update cursor position
                        const newText = beforeText + insertText + afterText;
                        textarea.value = newText;

                        const newCursorPos = start + insertText.length + cursorOffset;
                        textarea.setSelectionRange(newCursorPos, newCursorPos);
                        textarea.focus();

                        // Trigger input event to update preview
                        this.editor.handleInput();
                    }

                    toFullWidthNumber(num) {
                        const fullWidthNumbers = '０１２３４５６７８９';
                        return num.toString().split('').map(digit => fullWidthNumbers[parseInt(digit)]).join('');
                    }
                }

                // Initialize editor toolbar
                const editorToolbar = new EditorToolbar(editorController);
                console.log('EditorToolbar initialized');

                // Note: AutoSaveManager is now initialized by JAMdownApp

                // Test preview controller
                if (PreviewController.isMarkedAvailable()) {
                    console.log('marked.js is working correctly');

                    // Connect editor to preview with normalization
                    editorController.onInput((text) => {
                        // Normalize Japanese notation to standard Markdown
                        const normalizedText = NormalizationEngine.normalize(text);

                        // Render the normalized markdown
                        previewController.render(normalizedText);
                    });

                    // Initial render with placeholder content
                    const initialText = editorController.getText();
                    if (initialText) {
                        const normalizedText = NormalizationEngine.normalize(initialText);
                        previewController.render(normalizedText);
                    }

                } else {
                    console.error('marked.js is not working correctly');
                    previewController.handleRenderError(new Error('marked.js not available'), '');
                }

                // File Handler - Manages file upload and processing
                class FileHandler {
                    constructor(fileInputElement) {
                        console.log('FileHandler constructor called with:', fileInputElement);
                        this.fileInput = fileInputElement;
                        this.callbacks = [];
                        this.maxFileSize = 5 * 1024 * 1024; // 5MB limit
                        this.supportedExtensions = ['.md', '.jamd', '.jmd', '.txt'];

                        if (this.fileInput) {
                            this.setupEventListeners();
                            console.log('FileHandler initialized successfully');
                        } else {
                            console.error('FileHandler: fileInputElement is null or undefined');
                        }
                    }

                    setupEventListeners() {
                        this.fileInput.addEventListener('change', (event) => {
                            this.handleFileSelection(event);
                        });
                    }

                    async handleFileSelection(event) {
                        const files = event.target.files;
                        if (!files || files.length === 0) {
                            return;
                        }

                        const file = files[0];

                        try {
                            // Validate file
                            this.validateFile(file);

                            // Read file content
                            const content = await this.readFile(file);

                            // Create file data object
                            const fileData = {
                                name: file.name,
                                content: content,
                                type: this.getFileType(file.name),
                                size: file.size,
                                lastModified: new Date(file.lastModified)
                            };

                            // Notify callbacks
                            this.notifyCallbacks(fileData);

                        } catch (error) {
                            console.error('File processing error:', error);
                            this.handleFileError(error, file);
                        } finally {
                            // Clear the file input to allow re-selecting the same file
                            this.fileInput.value = '';
                        }
                    }

                    validateFile(file) {
                        // Check file size
                        if (file.size > this.maxFileSize) {
                            throw new Error(`File size (${this.formatFileSize(file.size)}) exceeds the maximum limit of ${this.formatFileSize(this.maxFileSize)}`);
                        }

                        // Check file extension
                        const extension = this.getFileExtension(file.name);
                        if (!this.supportedExtensions.includes(extension)) {
                            throw new Error(`File type "${extension}" is not supported. Supported types: ${this.supportedExtensions.join(', ')}`);
                        }

                        // Check if file is empty
                        if (file.size === 0) {
                            throw new Error('File is empty');
                        }
                    }

                    readFile(file) {
                        return new Promise((resolve, reject) => {
                            const reader = new FileReader();

                            reader.onload = (event) => {
                                try {
                                    const content = event.target.result;
                                    if (typeof content === 'string') {
                                        resolve(content);
                                    } else {
                                        reject(new Error('Failed to read file as text'));
                                    }
                                } catch (error) {
                                    reject(error);
                                }
                            };

                            reader.onerror = () => {
                                reject(new Error('Failed to read file'));
                            };

                            reader.onabort = () => {
                                reject(new Error('File reading was aborted'));
                            };

                            // Read as text with UTF-8 encoding
                            reader.readAsText(file, 'UTF-8');
                        });
                    }

                    getFileExtension(filename) {
                        const lastDot = filename.lastIndexOf('.');
                        return lastDot !== -1 ? filename.substring(lastDot).toLowerCase() : '';
                    }

                    getFileType(filename) {
                        const extension = this.getFileExtension(filename);
                        switch (extension) {
                            case '.jamd':
                                return 'jamd';
                            case '.jmd':
                                return 'jmd';
                            case '.md':
                                return 'md';
                            case '.txt':
                                return 'txt';
                            default:
                                return 'unknown';
                        }
                    }

                    formatFileSize(bytes) {
                        if (bytes === 0) return '0 Bytes';
                        const k = 1024;
                        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                        const i = Math.floor(Math.log(bytes) / Math.log(k));
                        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                    }

                    onFileSelected(callback) {
                        if (typeof callback === 'function') {
                            this.callbacks.push(callback);
                        }
                    }

                    notifyCallbacks(fileData) {
                        this.callbacks.forEach(callback => {
                            try {
                                callback(fileData);
                            } catch (error) {
                                console.error('Error in file callback:', error);
                            }
                        });
                    }

                    handleFileError(error, file) {
                        const errorMessage = `File Error: ${error.message}`;
                        console.error(errorMessage, file);

                        // Show user-friendly error message
                        alert(errorMessage);
                    }

                    // Trigger file selection dialog
                    selectFile() {
                        console.log('selectFile() called');
                        if (this.fileInput) {
                            console.log('File input exists, triggering click');
                            this.fileInput.click();
                        } else {
                            console.error('File input element not found');
                        }
                    }

                    // Get supported file types for display
                    getSupportedTypes() {
                        return [...this.supportedExtensions];
                    }

                    // Set maximum file size
                    setMaxFileSize(bytes) {
                        this.maxFileSize = bytes;
                    }
                }

                // Note: File handling is now managed by the main JAMdownApp class

                // Export Manager - Handles file downloads and clipboard operations
                class ExportManager {
                    constructor() {
                        this.isClipboardSupported = this.checkClipboardSupport();
                    }

                    checkClipboardSupport() {
                        return navigator.clipboard &&
                            typeof navigator.clipboard.writeText === 'function' &&
                            window.isSecureContext;
                    }

                    downloadFile(content, filename, fileType = 'md') {
                        try {
                            // Generate filename if not provided
                            if (!filename) {
                                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
                                filename = `jamdown-${timestamp}`;
                            }

                            // Remove existing extension if present
                            filename = filename.replace(/\.(md|jamd|jmd)$/i, '');

                            // Add appropriate extension
                            filename += `.${fileType}`;

                            // Determine MIME type
                            let mimeType = 'text/plain;charset=utf-8';
                            switch (fileType) {
                                case 'md':
                                    mimeType = 'text/markdown;charset=utf-8';
                                    break;
                                case 'jamd':
                                case 'jmd':
                                    mimeType = 'text/plain;charset=utf-8';
                                    break;
                            }

                            // Create blob with UTF-8 encoding
                            const blob = new Blob([content], { type: mimeType });

                            // Create download link (only once)
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.href = url;
                            link.download = filename;
                            link.style.display = 'none'; // Hide the link

                            // Trigger download
                            document.body.appendChild(link);
                            link.click();

                            // Clean up immediately
                            document.body.removeChild(link);
                            URL.revokeObjectURL(url);

                            console.log(`Downloaded: ${filename} (${this.formatFileSize(blob.size)})`);
                            return true;

                        } catch (error) {
                            console.error('Download error:', error);
                            this.showError('Failed to download file: ' + error.message);
                            return false;
                        }
                    }

                    // 後方互換性のためのレガシーメソッド
                    downloadAsMarkdown(content, filename = null) {
                        return this.downloadFile(content, filename, 'md');
                    }

                    // JAMDとしてダウンロード（日本語記法を保持した元のコンテンツ）
                    downloadAsJAMD(content, filename = null) {
                        return this.downloadFile(content, filename, 'jamd');
                    }

                    // JMDとしてダウンロード（日本語記法を保持した元のコンテンツ）
                    downloadAsJMD(content, filename = null) {
                        return this.downloadFile(content, filename, 'jmd');
                    }

                    async copyHTMLToClipboard(html) {
                        try {
                            if (this.isClipboardSupported) {
                                // Use modern Clipboard API
                                await navigator.clipboard.writeText(html);
                                console.log('HTML copied to clipboard using Clipboard API');
                                return true;
                            } else {
                                // Fallback method
                                return this.fallbackCopyToClipboard(html);
                            }
                        } catch (error) {
                            console.error('Clipboard error:', error);

                            // Try fallback method
                            try {
                                return this.fallbackCopyToClipboard(html);
                            } catch (fallbackError) {
                                console.error('Fallback clipboard error:', fallbackError);
                                this.showError('Failed to copy to clipboard. Please copy manually.');
                                return false;
                            }
                        }
                    }

                    fallbackCopyToClipboard(text) {
                        try {
                            // Create temporary textarea
                            const textarea = document.createElement('textarea');
                            textarea.value = text;
                            textarea.style.position = 'fixed';
                            textarea.style.left = '-9999px';
                            textarea.style.top = '-9999px';

                            document.body.appendChild(textarea);
                            textarea.focus();
                            textarea.select();

                            // Try to copy using execCommand
                            const successful = document.execCommand('copy');
                            document.body.removeChild(textarea);

                            if (successful) {
                                console.log('HTML copied to clipboard using fallback method');
                                return true;
                            } else {
                                throw new Error('execCommand copy failed');
                            }
                        } catch (error) {
                            throw new Error('Fallback copy method failed: ' + error.message);
                        }
                    }

                    formatFileSize(bytes) {
                        if (bytes === 0) return '0 Bytes';
                        const k = 1024;
                        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                        const i = Math.floor(Math.log(bytes) / Math.log(k));
                        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                    }

                    showError(message) {
                        // Simple error display - could be enhanced with better UI
                        alert(message);
                    }

                    showSuccess(message) {
                        // Simple success display - could be enhanced with better UI
                        console.log('Success:', message);
                    }

                    // Generate filename from content (extract title if available)
                    generateFilename(content) {
                        try {
                            // Look for first heading as filename
                            const lines = content.split('\n');
                            for (let line of lines) {
                                const trimmed = line.trim();
                                if (trimmed.startsWith('#')) {
                                    // Extract heading text
                                    let title = trimmed.replace(/^#+\s*/, '').trim();
                                    // Clean filename
                                    title = title.replace(/[<>:"/\\|?*]/g, '').substring(0, 50);
                                    if (title) {
                                        return title + '.md';
                                    }
                                }
                            }
                        } catch (error) {
                            console.warn('Error generating filename from content:', error);
                        }

                        // Fallback to timestamp
                        const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
                        return `jamdown-${timestamp}.md`;
                    }

                    // Export both markdown and HTML
                    async exportBoth(markdownContent, htmlContent) {
                        const results = {
                            markdown: false,
                            html: false
                        };

                        // Download markdown
                        const filename = this.generateFilename(markdownContent);
                        results.markdown = this.downloadAsMarkdown(markdownContent, filename);

                        // Copy HTML to clipboard
                        results.html = await this.copyHTMLToClipboard(htmlContent);

                        return results;
                    }
                }

                // Note: Export functionality is now handled by the main JAMdownApp class

                // Main Application Class - Coordinates all components
                class JAMdownApp {
                    constructor() {
                        this.components = {};
                        this.isInitialized = false;
                        this.errorCount = 0;

                        this.init();
                    }

                    async init() {
                        try {
                            console.log('Initializing JAMdown Pad...');

                            // Check prerequisites
                            this.checkPrerequisites();

                            // Initialize components
                            await this.initializeComponents();

                            // Setup global error handling
                            this.setupErrorHandling();

                            // Connect components
                            this.connectComponents();

                            // Setup keyboard shortcuts
                            this.setupKeyboardShortcuts();

                            // Initial render
                            this.performInitialRender();

                            this.isInitialized = true;
                            console.log('JAMdown Pad initialized successfully');

                            // Initialize auto-save manager
                            this.autoSaveManager = new AutoSaveManager(this.components.editor);

                            // Show welcome message if editor is empty and no content was loaded
                            if (!this.autoSaveManager.loadContent()) {
                                this.showWelcomeIfEmpty();
                            }

                        } catch (error) {
                            console.error('Failed to initialize JAMdown Pad:', error);
                            this.handleInitializationError(error);
                        }
                    }

                    checkPrerequisites() {
                        // Check marked.js availability
                        if (!PreviewController.isMarkedAvailable()) {
                            throw new Error('marked.js library is not available or not working correctly');
                        }

                        // Check required DOM elements
                        const requiredElements = ['editor', 'preview', 'file-input', 'upload-btn', 'download-md-btn', 'copy-html-btn'];
                        for (let id of requiredElements) {
                            if (!document.getElementById(id)) {
                                throw new Error(`Required element not found: ${id}`);
                            }
                        }
                    }

                    async initializeComponents() {
                        // Initialize editor controller
                        const editorElement = document.getElementById('editor');
                        this.components.editor = new EditorController(editorElement);

                        // Initialize preview controller
                        const previewElement = document.getElementById('preview');
                        this.components.preview = new PreviewController(previewElement);

                        // Initialize file handler
                        const fileInputElement = document.getElementById('file-input');
                        this.components.fileHandler = new FileHandler(fileInputElement);

                        // Initialize export manager
                        this.components.exportManager = new ExportManager();

                        console.log('All components initialized');
                    }

                    connectComponents() {
                        // Connect editor to preview with normalization
                        this.components.editor.onInput((text) => {
                            try {
                                const normalizedText = NormalizationEngine.normalize(text);
                                this.components.preview.render(normalizedText);
                            } catch (error) {
                                console.error('Error in editor-preview pipeline:', error);
                                this.handleComponentError('editor-preview', error);
                            }
                        });

                        // Connect file handler to editor
                        this.components.fileHandler.onFileSelected((fileData) => {
                            try {
                                this.components.editor.setText(fileData.content);
                                this.showFileLoadedMessage(fileData);

                                // Show file type specific message
                                let typeMessage = '';
                                switch (fileData.type) {
                                    case 'jamd':
                                        typeMessage = 'JAMDファイルを読み込みました - 日本語記法を保持';
                                        break;
                                    case 'jmd':
                                        typeMessage = 'JMDファイルを読み込みました - 日本語記法を保持';
                                        break;
                                    case 'md':
                                        typeMessage = 'Markdownファイルを読み込みました - 標準記法';
                                        break;
                                    case 'txt':
                                        typeMessage = 'テキストファイルを読み込みました';
                                        break;
                                    default:
                                        typeMessage = 'ファイルを読み込みました';
                                }
                                console.log(typeMessage);

                            } catch (error) {
                                console.error('Error loading file into editor:', error);
                                this.handleComponentError('file-loading', error);
                            }
                        });

                        // Connect upload button
                        const uploadButton = document.getElementById('upload-btn');
                        if (uploadButton) {
                            uploadButton.addEventListener('click', () => {
                                console.log('Upload button clicked');
                                if (this.components.fileHandler) {
                                    console.log('FileHandler exists, calling selectFile()');
                                    this.components.fileHandler.selectFile();
                                } else {
                                    console.error('FileHandler not initialized');
                                }
                            });
                            console.log('Upload button event listener attached');
                        } else {
                            console.error('Upload button not found');
                        }

                        // Connect clear button
                        const clearButton = document.getElementById('clear-btn');
                        if (clearButton) {
                            clearButton.addEventListener('click', () => {
                                if (confirm('エディタの内容をクリアしますか？\n（保存されたデータも削除されます）')) {
                                    this.components.editor.clear();
                                    this.autoSaveManager.clearSavedContent();
                                    console.log('Editor content cleared');
                                }
                            });
                        }

                        // Connect download buttons
                        const downloadMdButton = document.getElementById('download-md-btn');
                        const downloadJamdButton = document.getElementById('download-jamd-btn');
                        const downloadJmdButton = document.getElementById('download-jmd-btn');

                        downloadMdButton.addEventListener('click', () => {
                            this.handleDownload('md');
                        });

                        downloadJamdButton.addEventListener('click', () => {
                            this.handleDownload('jamd');
                        });

                        downloadJmdButton.addEventListener('click', () => {
                            this.handleDownload('jmd');
                        });

                        // Connect copy HTML button
                        const copyHtmlButton = document.getElementById('copy-html-btn');
                        copyHtmlButton.addEventListener('click', () => {
                            this.handleCopyHTML();
                        });

                        console.log('Components connected');
                    }

                    setupErrorHandling() {
                        // Global error handler
                        window.addEventListener('error', (event) => {
                            this.handleGlobalError(event.error, 'Global Error');
                        });

                        // Unhandled promise rejection handler
                        window.addEventListener('unhandledrejection', (event) => {
                            this.handleGlobalError(event.reason, 'Unhandled Promise Rejection');
                        });
                    }

                    setupKeyboardShortcuts() {
                        document.addEventListener('keydown', (event) => {
                            // Ctrl/Cmd + S: Download as .md
                            if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                                event.preventDefault();
                                this.handleDownload('md');
                            }

                            // Ctrl/Cmd + Shift + C: Copy HTML
                            if ((event.ctrlKey || event.metaKey) && event.shiftKey && event.key === 'C') {
                                event.preventDefault();
                                this.handleCopyHTML();
                            }

                            // Ctrl/Cmd + O: Open file
                            if ((event.ctrlKey || event.metaKey) && event.key === 'o') {
                                event.preventDefault();
                                this.components.fileHandler.selectFile();
                            }
                        });
                    }

                    performInitialRender() {
                        const initialText = this.components.editor.getText();
                        if (initialText.trim()) {
                            const normalizedText = NormalizationEngine.normalize(initialText);
                            this.components.preview.render(normalizedText);
                        }
                    }

                    showWelcomeIfEmpty() {
                        const currentText = this.components.editor.getText();
                        // Only show welcome message if editor is empty and no saved content was loaded
                        if (!currentText.trim()) {
                            const welcomeText = `# JAMdown Pad へようこそ！ 🎌

JAMdown Pad は日本語の全角文字と標準的な半角文字の両方を使って、シームレスにMarkdownを書くことができます。

## 以下の例を試してみてください：

### 日本語記法（全角）:
＃ 見出し
＊＊太字＊＊
＊斜体＊
＞ 引用文
・ リスト項目
１． 番号付きリスト
「リンク」（https://example.com）

｜列１｜列２｜列３｜
｜：ー｜：ー：｜ー：｜
｜左寄せ｜中央｜右寄せ｜
｜データ１｜データ２｜データ３｜

｀インラインコード｀
〜〜取り消し線〜〜
□ 未完了タスク
☑ 完了タスク
！「画像説明」（image.jpg）
脚注の参照［＾１］

### 標準記法（半角）:
# 見出し
**太字**
*斜体*
> 引用
* リスト項目
1. 番号付きリスト
[リンク](https://example.com)

| 列1 | 列2 | 列3 |
|:--------|:-------:|--------:|
| 左寄せ | 中央 | 右寄せ |
| データ1 | データ2 | データ3 |

\`インラインコード\`
~~取り消し線~~
- [ ] 未完了タスク
- [x] 完了タスク
![画像説明](image.jpg)
脚注参照[^1]

### 混在記法も使えます！
＃ 日本語見出し
**英語太字** と ＊＊日本語太字＊＊
・ 混在リスト with *英語斜体*

---

**ファイル形式:**
- **.md**: 標準マークダウン（日本語記法を半角に変換）
- **.jamd**: 日本語マークダウン（全角記法を保持）
- **.jmd**: 日本語マークダウンの短縮形（全角記法を保持）

**キーボードショートカット:**
- Ctrl/Cmd + S: .mdファイル保存
- Ctrl/Cmd + Shift + C: HTMLコピー
- Ctrl/Cmd + O: ファイルを開く

入力を始めて魔法を体験してください！ ✨`;

                            this.components.editor.setText(welcomeText);
                        }
                    }

                    handleDownload(fileType = 'md') {
                        try {
                            const currentText = this.components.editor.getText();
                            if (!currentText.trim()) {
                                alert('エディタが空です。まず内容を入力してください。');
                                return;
                            }

                            let content, filename, buttonId, buttonText;

                            switch (fileType) {
                                case 'md':
                                    // .mdファイルの場合、正規化されたコンテンツを使用（標準Markdown）
                                    content = NormalizationEngine.normalize(currentText);
                                    filename = this.components.exportManager.generateFilename(content);
                                    buttonId = 'download-md-btn';
                                    buttonText = '.md保存';
                                    break;

                                case 'jamd':
                                    // .jamdファイルの場合、元のコンテンツを使用（日本語記法を保持）
                                    content = currentText;
                                    filename = this.components.exportManager.generateFilename(content);
                                    buttonId = 'download-jamd-btn';
                                    buttonText = '.jamd保存';
                                    break;

                                case 'jmd':
                                    // .jmdファイルの場合、元のコンテンツを使用（日本語記法を保持）
                                    content = currentText;
                                    filename = this.components.exportManager.generateFilename(content);
                                    buttonId = 'download-jmd-btn';
                                    buttonText = '.jmd保存';
                                    break;

                                default:
                                    throw new Error(`Unsupported file type: ${fileType}`);
                            }

                            const success = this.components.exportManager.downloadFile(content, filename, fileType);

                            if (success) {
                                this.showButtonSuccess(buttonId, '✓ Downloaded', buttonText);
                            }
                        } catch (error) {
                            console.error('Download error:', error);
                            this.handleComponentError('download', error);
                        }
                    }

                    async handleCopyHTML() {
                        try {
                            const currentHTML = this.components.preview.getHTML();
                            if (!currentHTML.trim()) {
                                alert('プレビューが空です。まず内容を入力してください。');
                                return;
                            }

                            const success = await this.components.exportManager.copyHTMLToClipboard(currentHTML);

                            if (success) {
                                this.showButtonSuccess('copy-html-btn', '✓ コピー完了', 'HTMLコピー');
                            }
                        } catch (error) {
                            console.error('Copy HTML error:', error);
                            this.handleComponentError('copy-html', error);
                        }
                    }

                    showButtonSuccess(buttonId, successText, originalText) {
                        const button = document.getElementById(buttonId);
                        if (button) {
                            button.textContent = successText;
                            button.style.background = 'var(--success-bg)';
                            button.style.borderColor = 'var(--success-border)';
                            button.style.color = 'var(--success-text)';

                            setTimeout(() => {
                                button.textContent = originalText;
                                button.style.background = '';
                                button.style.borderColor = '';
                                button.style.color = '';
                            }, 2000);
                        }
                    }

                    showFileLoadedMessage(fileData) {
                        const uploadButton = document.getElementById('upload-btn');
                        if (uploadButton) {
                            const message = `✓ ${fileData.name}`;
                            uploadButton.textContent = message;
                            uploadButton.style.background = 'var(--success-bg)';
                            uploadButton.style.borderColor = 'var(--success-border)';
                            uploadButton.style.color = 'var(--success-text)';

                            setTimeout(() => {
                                uploadButton.textContent = 'ファイルを開く';
                                uploadButton.style.background = '';
                                uploadButton.style.borderColor = '';
                                uploadButton.style.color = '';
                            }, 3000);
                        }
                    }

                    handleComponentError(component, error) {
                        this.errorCount++;
                        console.error(`Component error (${component}):`, error);

                        // Show user-friendly error message
                        const message = `Error in ${component}: ${error.message}`;
                        alert(message);
                    }

                    handleGlobalError(error, type) {
                        this.errorCount++;
                        console.error(`${type}:`, error);

                        // Don't show alert for every global error to avoid spam
                        if (this.errorCount <= 3) {
                            console.warn('Global error occurred. Check console for details.');
                        }
                    }

                    handleInitializationError(error) {
                        const errorMessage = `
                            <div style="color: #dc3545; padding: 2rem; text-align: center; font-family: Arial, sans-serif;">
                                <h2>JAMdown Pad Failed to Initialize</h2>
                                <p><strong>Error:</strong> ${error.message}</p>
                                <p>Please refresh the page or check your browser console for more details.</p>
                            </div>
                        `;

                        const previewElement = document.getElementById('preview');
                        if (previewElement) {
                            previewElement.innerHTML = errorMessage;
                        }
                    }

                    // Public API methods
                    getEditor() {
                        return this.components.editor;
                    }

                    getPreview() {
                        return this.components.preview;
                    }

                    getExportManager() {
                        return this.components.exportManager;
                    }

                    isReady() {
                        return this.isInitialized;
                    }
                }

                // Theme Management
                class ThemeManager {
                    constructor() {
                        this.theme = localStorage.getItem('theme') || 'light';
                        this.init();
                    }

                    init() {
                        // Apply saved theme
                        this.applyTheme(this.theme);

                        // Setup theme toggle button
                        const themeToggle = document.getElementById('theme-toggle');
                        if (themeToggle) {
                            themeToggle.addEventListener('click', () => {
                                this.toggleTheme();
                            });
                        }

                        // Listen for system theme changes
                        if (window.matchMedia) {
                            const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                            mediaQuery.addListener(() => {
                                if (!localStorage.getItem('theme')) {
                                    this.applySystemTheme();
                                }
                            });
                        }
                    }

                    toggleTheme() {
                        this.theme = this.theme === 'light' ? 'dark' : 'light';
                        this.applyTheme(this.theme);
                        localStorage.setItem('theme', this.theme);
                    }

                    applyTheme(theme) {
                        document.documentElement.setAttribute('data-theme', theme);
                        this.updateThemeIcon(theme);
                    }

                    applySystemTheme() {
                        const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                        this.theme = prefersDark ? 'dark' : 'light';
                        this.applyTheme(this.theme);
                    }

                    updateThemeIcon(theme) {
                        const sunIcon = document.querySelector('.sun-icon');
                        const moonIcon = document.querySelector('.moon-icon');

                        if (sunIcon && moonIcon) {
                            if (theme === 'dark') {
                                sunIcon.style.display = 'none';
                                moonIcon.style.display = 'block';
                            } else {
                                sunIcon.style.display = 'block';
                                moonIcon.style.display = 'none';
                            }
                        }
                    }
                }



                // Auto Save Manager
                class AutoSaveManager {
                    constructor(editorController) {
                        this.editor = editorController;
                        this.saveKey = 'jamdown-pad-content';
                        this.lastSaveTime = 0;
                        this.saveDelay = 1000; // 1秒後に保存
                        this.saveTimer = null;

                        this.init();
                    }

                    init() {
                        // Load saved content on initialization
                        this.loadContent();

                        // Setup auto-save on editor input
                        this.editor.onInput((text) => {
                            this.scheduleAutoSave(text);
                        });

                        // Save on page unload
                        window.addEventListener('beforeunload', () => {
                            this.saveContent(this.editor.getText());
                        });

                        // Show save status
                        this.createSaveIndicator();
                    }

                    scheduleAutoSave(text) {
                        // Clear existing timer
                        if (this.saveTimer) {
                            clearTimeout(this.saveTimer);
                        }

                        // Schedule new save
                        this.saveTimer = setTimeout(() => {
                            this.saveContent(text);
                        }, this.saveDelay);
                    }

                    saveContent(content) {
                        try {
                            const saveData = {
                                content: content,
                                timestamp: Date.now(),
                                version: '1.0'
                            };

                            localStorage.setItem(this.saveKey, JSON.stringify(saveData));
                            this.lastSaveTime = Date.now();
                            this.updateSaveIndicator('saved');

                            console.log('Content auto-saved');
                        } catch (error) {
                            console.error('Failed to save content:', error);
                            this.updateSaveIndicator('error');
                        }
                    }

                    loadContent() {
                        try {
                            const savedData = localStorage.getItem(this.saveKey);
                            if (savedData) {
                                const data = JSON.parse(savedData);

                                // Only load if there's actual content (not just the welcome message)
                                if (data.content && data.content.trim() && !data.content.includes('JAMdown Pad へようこそ')) {
                                    this.editor.setText(data.content);
                                    this.updateSaveIndicator('loaded');

                                    const saveDate = new Date(data.timestamp);
                                    console.log(`Content loaded from ${saveDate.toLocaleString()}`);
                                    return true;
                                }
                            }
                        } catch (error) {
                            console.error('Failed to load saved content:', error);
                        }
                        return false;
                    }

                    createSaveIndicator() {
                        const indicator = document.createElement('div');
                        indicator.id = 'save-indicator';
                        indicator.className = 'save-indicator';
                        indicator.innerHTML = `
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                                <polyline points="17,21 17,13 7,13 7,21"/>
                                <polyline points="7,3 7,8 15,8"/>
                            </svg>
                            <span class="save-text">自動保存</span>
                        `;

                        // Add to editor header
                        const editorHeader = document.querySelector('.editor-header');
                        if (editorHeader) {
                            editorHeader.appendChild(indicator);
                        }
                    }

                    updateSaveIndicator(status) {
                        const indicator = document.getElementById('save-indicator');
                        if (!indicator) return;

                        const textElement = indicator.querySelector('.save-text');

                        // Remove existing status classes
                        indicator.classList.remove('saving', 'saved', 'error', 'loaded');

                        switch (status) {
                            case 'saving':
                                indicator.classList.add('saving');
                                textElement.textContent = '保存中...';
                                break;
                            case 'saved':
                                indicator.classList.add('saved');
                                textElement.textContent = '保存済み';
                                setTimeout(() => {
                                    textElement.textContent = '自動保存';
                                    indicator.classList.remove('saved');
                                }, 2000);
                                break;
                            case 'error':
                                indicator.classList.add('error');
                                textElement.textContent = '保存エラー';
                                setTimeout(() => {
                                    textElement.textContent = '自動保存';
                                    indicator.classList.remove('error');
                                }, 3000);
                                break;
                            case 'loaded':
                                indicator.classList.add('loaded');
                                textElement.textContent = '復元済み';
                                setTimeout(() => {
                                    textElement.textContent = '自動保存';
                                    indicator.classList.remove('loaded');
                                }, 3000);
                                break;
                        }
                    }

                    clearSavedContent() {
                        try {
                            localStorage.removeItem(this.saveKey);
                            console.log('Saved content cleared');
                        } catch (error) {
                            console.error('Failed to clear saved content:', error);
                        }
                    }

                    getSaveInfo() {
                        try {
                            const savedData = localStorage.getItem(this.saveKey);
                            if (savedData) {
                                const data = JSON.parse(savedData);
                                return {
                                    hasContent: !!data.content,
                                    timestamp: data.timestamp,
                                    size: data.content ? data.content.length : 0
                                };
                            }
                        } catch (error) {
                            console.error('Failed to get save info:', error);
                        }
                        return null;
                    }
                }

                // Initialize theme manager
                const themeManager = new ThemeManager();

                // Initialize the main application
                const app = new JAMdownApp();

                // Make app globally available for debugging
                window.JAMdownApp = app;
                window.ThemeManager = themeManager;

            } else {
                console.error('Editor or preview element not found');
            }
        }
    </script>
</body>

</html>